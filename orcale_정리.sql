
/* ORACLE 기본
 
 1. RDBMS
	 기본단위 : 테이블

	* EMP(사원정보 테이블)
	* empno(사번), ename(사원명), job(직책), mgr(직속상관 사원번호), hiredate(입사일), sal(급여), comm(추가수당), deptno(부서번호)
	* NUMBER(4,0) : 전체 자릿수 4자리(소수점 자릿수 0)
	* VARCHARTO2(10) : 문자열 데이터 => 문자열 10byte (VAR : 가변 ex. 7byte 문자열 저장했다면 7byte 공간만 사용)
		 			   영어 : 10문자 / 한글 : 2byte (utf-8 : 3byte) 할당
	* DATE : 날짜
	* DEPT(부서테이블)
	* deptno(부서번호), dname(부서명), loc(부서위치)
	* SALGRADE(급여테이블)
	* grade(급여 등급), losal(최저급여), hisal(최대급여)

	* 개발자 : C(insert)R(read)U(update)D(delete)
	* SQL(Structured Query Language : 구조질의언어) : RDBMS 데이터를 다루는 언어
 	 ㄴ 모든 RDBMS에서 사용 가능한 표준화된 언어

	* 조회 : cost가 있음(시간이 얼마나 걸리는가) => 시간을 얼마나 빠르게 조회하는가가 중요
	* SQL 구문 실행 순서
		① FROM => ② WHERE => ③ SELECT => ④ ORDER by
		
	* XE 버전 한글의 바이트 수 : 3byte
	* 
<< R (READ) >>

 << 연산자 >>
 	1) 산술연산자 : +, -, *, /
 	2) 비교연산자 : >, <, >=, <=, =
 	3) 등가비교연산자 : =, 같지 않다의 형태는 많음 : !=, <>, ^=
 	4) 논리부정연산자 : NOT
 	5) 			  : IN
 	6) 범위연산자 : BETWEEN A AND B
 	7) 검색연산자 : LIKE 연산자와 와일드카드(_ , %)
 	8) IS NULL : 널과 같다
 	9) 집합연산자
 		UNION(합집합) : 타입 일치만 확인 => 타입이 맞는다면 연결
 			=> UNION : 중복 제외하고 출력
 			=> UNION ALL : 중복 데이터도 출력
 		MINUS(차집합)
 		INTERSECT(교집합)
 			=> 컬럼의 갯수가 서로 동일해야 한다

 << 오라클 함수 >>
 	- 내장함수
 		1. 문자함수
 			1) 대소문자를 바꿔주는 함수
 				upper()
 				lower()
 				initcap()
 			2) 문자의 길이를 구하는 함수
 				LENGTH()
 				LENGTHB() : 문자열 바이트 수 반환
 			3) 문자열 일부 추출
 				SUBSTR(문자열데이터, 시작위치, 추출길이)
 					=> 시작위치
 						양수 : 왼쪽부터 => 1
 						음수 : 오른쪽부터 => 맨끝부터 -1
 			4) 문자열 데이터 안에서 특정 문자 위치 찾기
 				INSTR(①대상문자열, ②위치를 찾으려는 문자, ③시작위치, ④시작위치에서 찾으려는 문자가 몇번째인지)
 					=> ①, ② 필수
 			5) 특정 문자를 다른 문자로 변경
 				REPLACE(원본 문자열, 찾을 문자열, 변경 문자열)
 					=> 변경 문자열을 안주면 해당 문자열 자리 삭제
 			6) 두 문자열 데이터를 합치기
 				CONCAT(문자열1, 문자열2)
 					=> 두개밖에 못해서 범용성 떨어짐
 				|| : 합칠 수 있음!
 			7) 특정 문자 제거
 				TRIM(삭제옵션(선택사항), 삭제할 문자(선택사항), FROM 원본 문자열(필수))
 				LTRIM() : 왼쪽 제거
 				RTRIM() : 오른쪽 제거
 			8) 데이터 공간을 특정 문자로 채우기
 				LPAD(데이터, 데이터 자릿수, 채울 문자) : 왼쪽에 채울건지
 				RPAD() : 오른쪽에 채울건지
 					
 		2. 숫자 함수
 			1) ROUND(지정 문자열, 몇번째에서 할지) : 반올림
 			2) TRUNC(지정 문자열, 몇번째에서 할지) : 버림
 			3) CEIL() : 가장 큰 정수
 			4) FLOOR() : 가장 작은 정수
 			5) MOD() : 나머지
 	
		3. 날짜 함수
 			1) SYSDATE : 오늘날짜/시간
 			2) ADD_MONTHS() : 몇개월 이후 날짜 구하기
 			3) MONTHS_BETWEEN() : 두 날짜간의 개월 수 차이 구하기
 			4) NEXT_DAY() / LAST_DAY : 돌아오는 요일, 달의 마지막 날짜 구하기
 	
 		4. 자료형을 변환하는 형변환 함수
 			1) TO_CHAR() : 숫자 또는 날짜 데이터를 문자열 데이터로 반환
 				-날짜(SYSDATE) 형변환
 					TO_CHAR(SYSDATE, 'MM'), => 03
					TO_CHAR(SYSDATE, 'MON'), => 3월 
					TO_CHAR(SYSDATE, 'MONTH'), => 3월 
					TO_CHAR(SYSDATE, 'DD'), => 19
					TO_CHAR(SYSDATE, 'DY'), => 수
					TO_CHAR(SYSDATE, 'DAY'), => 수요일
					TO_CHAR(SYSDATE, 'HH24:MI:SS'), => 17:59:04
					TO_CHAR(SYSDATE, 'HH12:MI:SS AM'), => 05:59:04 오후
					TO_CHAR(SYSDATE, 'HH:MI:SS PM') => 05:59:04 오후
		
					* 12시간제 이므로 HH24 라고 명시하지 않으면 05:59:04 식으로 도출
					* AM, PM => 아무거나 주면 오전/오후 나옴
				
				9 : 숫자 한자리를 의미
				0 : 숫자 한자리를 의미(빈자리를 0으로 채움)
 			2) TO_NUMBER('문자열데이터','인식할숫자형태') : 문자열 데이터를 숫자 데이터로 반환
 				=> 문자 형식의 숫자를 -> NUMBER 숫자 데이터로 반환할 시 => 형식을 주어야 함
 			3) TO_DATE(날짜 형식에 맞는 숫자, 날짜와 맞춘 형식) : 문자열 데이터를 날짜 데이터로 반환
 	
 				* NUMBER + '문자숫자' => 덧셈 가능 => 자동형변환
 			
 		5. NULL
			=> 산술연산이나 비교연산자(IS NULL OR IS NOT NULL)가 제대로 수행되지 않음
			
			1) NVL(널여부를 검사할 데이터,널일때 반환할데이터)
			2) NVL2(널여부를 검사할 데이터,널이아닐때 반환할 데이터,널일때 반환할데이터)
			
		6. 자바의 if, switch 구문과 유사
			1) DECODE
				DECODE(
				검사대상이 될 데이터, 
				조건1, 조건1 만족시 반환할 결과,
				조건2, 조건2 만족시 반환할 결과,
		        조건1~조건n 일치하지 않을때 반환할 결과 (선택)
		        )
			2) CASE
				CASE 검사대상이 될 데이터 
			     WHEN  조건1 THEN 조건1 만족시 반환할 결과
			     WHEN  조건2 THEN 조건2 만족시 반환할 결과
			     ELSE  조건1~조건n 일치하지 않을때 반환할 결과 (선택)
				 END

		7. 하나의 열에 출력 결과를 담는 다중행 함수
 			=> 모두 NULL 값 제외하고 연산해줌
 			
 			1) sum() : 합
 			2) count()
 			3) max()
 			4) min()
 			5) avg()
 	
 			* ALL 은 중복된 거 포함 할건지 안할 건지의 의미
 		
 		8. GROUP BY
 			=> JOIN 시에 조인 열의 값이 달라지고 JOIN의 값을 넣으면 에러가 뜸 => 열의 갯수가 맞지 않아서 GROUP 지정해야함
 			- 사용
 				GROUP BY 컬러명 HAVING 조건
 		
 		9. 조인 (join)
 			=> 여러 종류의 데이터를 다양한 테이블에 나누어 저장하기 때문에 여러 테이블의 데이터를 조합하여 출력할 때가 많다.
 			   이 때 사용하는 방식이 조인(join)
 			   
 			   * 특이한 조인 : hr(230번 줄) 참고
 
 			- 종류
 				1) 내부조인(inner join) : 연결이 안되는 데이터는 제외
 					=> 일치하거나 내부에 있어야 조인이 됨
 					1. 등가조인 : 같은지 여부
 					2. 비등가 조인 : 부등호 표현
 					3. 자체(self) 조인 : 내꺼에 내꺼 연결
 			
 				2) 외부조인(outer join) : 연결 안되는 데이터 보기
 					1. 왼쪽 외부조인(left outer join) : 오른쪽 테이블의 데이터 존재 여부와 상관없이 왼쪽 테이블 기준으로 출력
 						=> 왼쪽을 기준으로 뽑으면 left
 					2. 오른쪽 외부조인(right outer join) : 왼쪽 테이블의 데이터 존재 여부와 상관없이 오른쪽 테이블 기준으로 출력
 						=> 오른쪽을 기준으로 뽑으면 right
 				
 			- 표준 문법을 사용한 조인
 				1) 내부조인
 					inner 조인(내부조인)
 						=> (INNER) JOIN 테이블명 ON 조인 조건
 						=> INNER 생략 가능
 				2) 외부조인
 					OUTER 조인(외부조인)
 						=> LEFT/RIGHT OUTER JOIN 테이블명 ON 조인조건
 						
 		10. 서브쿼리(SUBQUARY)
 			=> SQL 구문을 실행하는데 필요한 데이터를 추가로 조회하고자 SQL 구문 내부에서 사용하는 SELECT 문
 			=> 특수한 몇몇 경우를 제외한 대부분의 서브쿼리에서는 ORDER BY 절을 사용할 수 없음
 			=> 서브쿼리의 SELCET 절에 명시한 열은 메인쿼리의 비교 대상과 같은 자료형(컬럼)과 같은 개수로 지정
 			=> 서브쿼리에 있는 SELECT문의 결과 행 수는 함께 사용하는 메인쿼리의 연산자 종류와 어울려야 함
 			
 			* 쿼리가 묶여있을 때 묶여있는 쿼리문만 실행시키고 싶다면 블록으로 묶어서 실행
 			* SELECT 절에도 사용 가능
 				=> 결과가 반드시 하나만 반환되어야 함 (반환 컬럼이 하나여야만 함)
 			
 			- 형태
 				() 안에 찾는 값을 조회하는 SELECT 문 삽입
 				=> 연산자 등의 비교 또는 조회 대상 오른쪽에 놓이며 괄호로 묶어서 사용
 				
 			- 종류
 				1) 단일행 서브쿼리 : 서비쿼리문의 실행결과가 하나의 행인 서브쿼리
 					=> 사용 연산자 : >, < ,>=, <=, <>, ^=, !=
 					
 				2) 다중행 서브쿼리 : 서비쿼리문의 실행결과가 여러개의 행인 서브쿼리
 					=> 사용 연산자 : IN, ANY(SOME), ALL, EXISTS
 						1) ANY / SOME : 서브쿼리가 반환한 여러 결과값 중 메인 쿼리와 조건식을 사용한 결과가
 									 하나라도 TRUE 라면 메인쿼리 조건식을 TRUE 로 반환
 									 	=> 하나씩 일일히 비교하는 동시에 하나라도 TRUE 면 반환하기에 단일행의 최대값을 비교하는 효과를 줌
 									 	   ANY / SOME => 단일행의 MAX와 같은 효과를 줌
 										=> IN 과 같은 효과 : = ANY / SOME ('=' 붙여야 같음)
 											=> IN 을 더 많이 사용
 											
 						2) ALL : 서브쿼리의 모든결과가 조건식에 맞아 떨어져야만 메인쿼리의 조건식이 TRUE
 								=> 모든 값을 비교하는 것이기에 하나라도 FALSE 면 출력이 안되고 모두 만족하는 값만 반환
 								   단일행의 최소값을 비교하는 효과를 줌
 								   ALL => 단일행의 MIN과 같은 효과를 줌
 								   
 						3) EXISTS : 서브쿼리에 결과값이 하나 이상 있으면 조건식이 모두 TRUE, 없으면 FALSE
 							=> 서브쿼리문의 결과가 나오면 모두 나오고, 안나오면 모두 안나옴
 							
 				3) 다중열 서브쿼리 : 서브쿼리의 SELECT 절에 비교할 데이터를 여러개 지정
 					=> 2개의 서브쿼리 값을 뽑으면 본문의 찾는 값도 2개를 뽑아야 함 (비교대상 일치)
 		
<< C (INSERT) >> : 삽입
	참고 : scott(1368)
		
	- 삽입
		- 기본형태 => 기준 : 필드명
			INSERT INTO 테이블명(필드명, 필드명, ....)
 			VALUES(값1, 값2...)
 			
 				=> 필드명과 값의 개수가 같아야 작성이 됨
 				=> Number 인 경우 자릿수에 맞게 입력해야 함
 				=> 컬럼의 개수가 모자르게 (필드명)을 쓰고 값을 입력하면 null 로 삽입 됨
 					=> 필드명 생략은 테이블의 현재 열 순서대로 나열되었다고 가정하고 데이터 처리
 					=> properties의 Not Null 에 체크가 안 되어있어야 가능
 					
 				* 날짜데이터 삽입
 				=> '' <- 필수
 				=> YYYY-MM-DD or YYYY/MM/DD
 				 				
 		- SELECT 구문의 형태
 				INSERT INTO 테이블명(필드명, 필드명, ....)
 				SELECT 문
 					=> VALUES 대신 사용
 			
<< U (UPDATE) >>
	참고 : scott(1422)
	
	- 기본형태
		UPDATE 테이블명
		SET 변경할 열 = 값, 변경할 열 = 값...
		WHERE 데이터를 변경할 대상 행을 선별하는 조건 나열
			
			=> WHERE 절이 없으면 해당 열의 값이 모두 변경이 되기 때문에 조심해야 함

<< D (DELETE) >>
	참고 : scott(1442)
	
	- 기본형태
		1) DELETE FROM 테이블명
		   WHERE 삭제할 조건
		
		2) DELETE 테이블명
		   WHERE 삭제할 조건
		   		
		   		=> FROM 은 선택
		   		=> WHERE 절이 없으면 해당 테이블의 값이 모두 삭제 되기 때문에 조심해야 함
 
<< 트랜잭션 >> : ALL(전부 실행) or NOTHING(전부 취소)
	참고 : scott(1527)
	
	- DML(데이터 조작어) 일 때만 일어남
		1) INSERT
		2) UPDATE
		3) DELETE
		
		* Auto Commit : 커밋 자동 실행
		
		- COMMIT : 전부 실행
			=> 구문 실행 후 진짜 실행 => COMMIT
		- ROLLBACK : 전부 취소
			=> 구문 실행 후 전부 취소 => ROLLBACK

		- 세션
			=> 데이터베이스 접속 후 작업을 수행한 후 접속을 종료하기까지 전체 기간
	
			*dbeaver 에서 커밋을 안한 실행상태에서 SQL plus 에서 똑같은 작업을 수행하면 => Lock
				=> 커밋을 하는지 롤백을 하는지 모르는 상태기에 Lock 을 검
			
	- DDL(데이터 정의어) : 객체(테이블)를 생성, 변경, 삭제
	
			* ROLLBACK 개념 X
			** 테이블명 규칙 
				1. 문자로 시작 (영문자, 한글, 숫자 가능)
				2. 테이블 이름은 30byte 이하
				3. 같은 사용자 안에서는 테이블명 중복 불가
				4. SQL 예약어는 테이블 이름으로 사용 금지
					* 예약어 : SELECT, FROM 등...

		1) CREATE : 테이블 생성
			- 작성
				CREATE TABLE 테이블명(
					컬럼명1 자료형, 
					컬럼명2 자료형, 
					컬럼명3 자료형
					)
				- 복사
					1) 기존테이블 구조와 데이터를 복사 후 새 테이블 생성
						=> CREATE TABLE 테이블명 AS SELECT * FROM 복사대상;
			
					2) 기존테이블의 구조(열)만 복사 후 새 테이블 생성
						=> CREATE TABLE 테이블명 AS SELECT * FROM 복사대상 WHERE 1<>1;
						
		2) ALTER : 테이블 변경 => 열 관련만
			1) 열 추가
				- 작성
					ALTER TABLE 테이블명 ADD 컬럼명 자료형
			2) 열 이름 변경
				- 작성
					ALTER TABLE 테이블명 RENAME COLUMN 기존컬럼명 바꿀컬럼명;
			3) 열 자료형 변경
				- 작성
					ALTER TABLE 테이블명 MODIFY 컬럼명 자료형(바꿀 값);
				* ORA-01440: 정도 또는 자리수를 축소할 열은 비어 있어야 합니다
					=> 자료가 이미 공간을 차지한 상태에서 자료값 보다 길이를 줄이면 에러남
			4) 특정 열 삭제
				- 작성
					ALTER TABLE 테이블명 DROP COLUMN 컬럼명;
					
		3) DROP : 테이블 삭제
			- 작성
				DROP TABLE 테이블명;
				
		4) TRUNCATE : 테이블 전체 데이터 삭제
			- 작성
				1) DELETE FROM 테이블명;
					=> ROLLBACK 가능
				2) TRUNCATE TABLE 테이블명;
					=> ROLLBACK 안됨
					
		5) RENAME : 테이블 이름 변경
			- 작성
				RENAME 기존테이블명 TO 바꿀테이블명;
		
<< 오라클 객체(테이블) >>
	참고 : scott(1622), ststem.sql(21)
	
	1) 오라클 데이터베이스 테이블
		1. 사용자 테이블
		2. 데이터 사전 : 일반 사용자가 접근하는 곳은 아님
			=> 중요한 데이터(사용자, 권한, 메모리, 성능 등...)
			=> USER_*, ALL_*, DBA_, V$_*
			=> 사용하는 경우가 흔치 않음
			
	2) 인덱스 : 검색을 빠르게 처리
		1. FULL SCAN
		2) INDEX SCAN
		
		- 인덱스 생성
			CREATE INDEX 인덱스명 ON 테이블명(열이름 ASC OR DESC, 열 이름....);
	
		- 인덱스 삭제
			 DROP INDEX 인덱스명
			 
	3) VIEW : 가상테이블
		=> 실제 물리적으로 저장된 테이블이 아님
		=> 아무나 생성 불가 => 권한을 가진 사람만 생성가능
		
		- 사용이유
			1) 보안성 : 특정 열을 노출하고 싶지 않을 때
			2) 편리성 : SELECT 문의 복잡도 완화	
		
		- 권한부여
			GRANT CREATE VIEW TO 사용자명;
		
		- 생성
			CREATE VIEW 뷰이름(열이름1, 열이름2 ...) AS (저장할 SELECT 구문)
			
	4) 시퀀스 : 특정 규칙에 따른 연속 숫자를 생성하는 객체
		=> 오라클 데이터베이스에만 존재
		=> 게시판 번호, 멤버 번호 등...
		=> 실행 했을 때 시퀀스 번호는 발행 즉시 되기 때문에 오류가 나도 번호가 초기화 된다거나 하지 않음
		
		- 생성
			CREATE SEQUENCE 시퀀스명;
				=> 기본 생성 코드
					CREATE SEQUENCE SCOTT.BOARD_SEQ 
					INCREMENT BY 1							=> 시퀀스에서 생성할 번호의 증가값 / 기본값 : 1
					MINVALUE 1								=> 시퀀스에서 생성할 번호의 최솟값 / 기본값 : NOMINVALUE (1 -> 오름차순)
					MAXVALUE 9999999999999999999999999999	=> 시퀀스에서 생성할 번호의 최댓값
					NOCYCLE 								=> 1 ~ MAXVALUE 번호가 다 발행된 후에 새로운 번호 요청시 에러 발생시킴
					CACHE 20 								=> 시퀀스가 생성할 번호를 메모리에 미리 할당해 놓을 개수를 지정
					NOORDER									=> 오름차순
					
					* CYCLE : 1 ~ MAXVALUE 번호가 다 발행된 후에 다시 1부터
						=> NOCYLCE 이면 MAXVALUE 이후로는 더이상 발행 안됨
						=> CYCLE 이 돌면 MINVALUE 값으로 돌아가서 시작함
					* NOCACHE : 미리 할당하지 말기
		
		- 부를 수 있는 명령어
			1) 시퀀스명.CURRVAL : 가장 마지막으로 생성된 시퀀스 확인]
			2) 시퀀스명.NEXTVAL : 시퀀스 발행
			
<< 제약조건 >> : ★★★★★ 아주중요 ★★★★★
	참고 : scott(1703)
	=> 테이블에 저장할 데이터를 제약하는 특수한 규칙
	
	1) NOT NULL : 빈 공간을 허용하지 않음
		- 생성 : 테이블 생성시
			컬럼명 자료형 제약조건명 NOT NULL 
				=> 제약조건명 : 선택, 중복 불가
				
		- NOT NULL 추가
			ALTER TABLE 테이블명 MODIFY (컬럼명 NOT NULL);
				=> 이미 생성된 테이블에 제약조건 지정은 가능
				   but. 이미 삽입된 데이터가 제약조건을 만족해야 함
				   
		- 제약조건 이름 변경
			ALTER TABLE 테이블명 RENAME CONSTRAINT 기존제약조건명 TO 변경제약조건명;
		
		- 제약조건 삭제
		ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;
		
		* NULL 입력 or 비어있으면 -> null 임
			=> 공백 : 문자열임
			
	2) UNIQUE : 중복불가
		- 생성
			컬럼명 자료형 제약조건명 UNIQUE
		
		=> 데이터에 중복을 허용하지 않음
			=> NULL 은 중복대상(무결성 제약조건)에서 제외
		
		* 데이터 무결성
			=> DB에 저장되는 데이터의 정확성과 일치성 보장
			=> DML 과정에서 지켜야 하는 규칙
			- 무결성 제약 조건(SCOTT.SYS_C008358)에 위배됩니다
				=> 데이터의 정확성과 일치성을 보장하지 못함
	
	3) PRIMARY KEY (PK) : 유일하게 하나만 존재
		- 생성
			컬럼명 자료형 제약조건명 PRIMARY KEY
			
		=> NOT NULL + UNIQUE
		=> 컬럼 1개만 지정 가능
	
	4) FOREIGN KEY (FK, 외래키) : 다른 테이블과 관계 맺기
		- JOIN 구문 => 외래키임
			=> ex. EMP(deptno), DEPT(deptno)
				=> EMP 테이블에 deptno 는 DEPT 테이블의 deptno 값을 참조해서 삽입
		
		- 작성 순서 (INSERT 시 주의!)
			1. 참조 대상이 되는 테이블(부모) 먼저 작성
			2. 참조 대상이 되는 테이블(부모)의 데이터 작성
			3. 참조하는 테이블의 데이터 삽입
				컬럼명 자료형 REFERENCES 참조테이블(참조테이블 컬럼명)
			
			* ORA-02291: 무결성 제약조건(SCOTT.EMPFK_DEPTNO_FK)이 위배되었습니다- 부모 키가 없습니다
				=> 참조대상이 되는 테이블의 데이터 삽입
		
		- 삭제순서 (DELETE 시 주의!)
			1. 참조하는 테이블(자식)의 데이터 삭제
			2. 참조 대상이 되는 테이블(부모) 데이터 삭제
			
			- 한번에 해결
				1. 컬럼명 자료형 REFERENCES 참조테이블(참조테이블 컬럼명)
					+ ON DELETE CASCADE
					=> 부모 삭제시 자식도 같이 삭제
				2. 컬럼명 자료형 REFERENCES 참조테이블(참조테이블 컬럼명)
					+ ON DELETE SET NULL
					=> 부모 삭제시 연결된 자식의 부모를 NULL로 변경
	
	5) CHECK : 데이터 형태와 범위를 지정
	
	6) DEFAULT : 기본값 설정
*/